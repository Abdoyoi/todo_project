Report 

1. Introduction 

  

I worked with my group on this assignment. We were asked to design and implement a command-line To-Do List Manager using shell scripting. The command-line To-Do List Manager needed a script that lets users manage tasks directly from the terminal. The script had to use file handling, argument parsing, loops, conditionals and text processing tools such, as awk and grep. We wrote the script. We tested the command-line To-Do List Manager. We made sure the command-line To-Do List Manager works as expected. 

  

Our script called todo.sh lets users create to‑do lists. The script lets users add tasks. The script lets users view tasks. The script lets users search tasks. The script lets users mark tasks as complete. The script lets users tasks. The script stores each to‑do list, in its file. The file storage makes the program easy to manage and easy to extend. We learned how command‑line tools work. The project gave us experience writing shell scripts and debugging shell scripts. 

  

2. Overall Design 

  

We decided to keep all task data in text files. Plain text files are easy to read and easy to use with tools. We put each to‑do list in the folder called todo_data. The folder called todo_data holds a file, for each to‑do list. For example work.todo is a file for a to‑do list. Personal.todo is a file, for a to‑do list. 

  

Here is the rule. I write each task on a line using the format below: 

  

id|status|description|due|priority|tags|recurrence 

  

I used the structure to extract and modify the fields when I completed a task or deleted a task. The pipe characters served as separators. The pipe characters let me process each field with awk. 

  

We built the script to be fully command line driven. The script lets users run all actions, with options such, as --add, --view --complete and --delete. The script follows the way real Unix utilities behave. 

  

3. Implementation Details 

3.1 Adding Tasks 

  

Tasks are added with the option. When a new task is added the script automatically assigns the task an ID. The script checks the existing ID in the list file. Then adds one. The script makes sure that the task IDs stay unique even if the tasks are deleted later. 

  

I can add arguments, like date, priority, tags and recurrence. If the optional arguments are not given the fields stay empty. The fields are set to default values. 

  

3.2 Viewing Tasks 

  

When I run the command with the --view option I see all tasks, in a selected list. The tasks appear in a format that includes the task ID, the description, the due date the priority, the tags and the completion status. If a list is empty the script prints (no tasks). The user then knows the list exists but contains no entries. 

  

3.3 Completing Tasks 

  

When I mark a task as complete using the command --complete <id> the task status changes from 0, to 1. The output then shows the task as "Complete”. I can see away which tasks are finished. 

  

For recurring tasks the script automatically creates a task, with the due date when the current task is completed. I set up the script to do that. The script uses date calculations inside a function to set the due date. 

  

3.4 Deleting Tasks 

  

I use the option to remove tasks. The --delete option rewrites the list file. Leaves out the task that has the matching ID. The rewrite does not corrupt the file. The rewrite keeps the remaining tasks. 

  

3.5 Searching Tasks 

  

I use the --search option to find tasks by keyword. The feature runs grep with ignore case, across every field of each task. The feature checks the title, the description, the tags, the dates and any other field. The feature lets me locate a task fast. I do not have to scroll through a list. 

  

4. Argument Parsing 

  

Command-line arguments get processed with a while loop and a case statement. Each recognised option sets a variable. The variable later tells the function that should run. The while loop and the case statement keep the code organized. The while loop and the case statement also make adding new options easier. 

  

I check for unknown arguments. When the program finds unknown arguments, the program prints an error message. The error message improves usability. Prevents behaviour. 

  

5. The Challenges We Faced 

  

During development I ran into a challenge. The challenge was debugging syntax errors that came from missing or badly pasted parts of the script. Bash error messages were hard to read at first. The error messages often pointed to missing functions or broken case statements. I fixed the problem by checking line numbers by looking at the script structure and by testing each feature one step at a time. 

  

Another challenge was making sure the script ran correctly each time. The script also had to keep all data. I used files when I edited the task lists. The temporary files stopped data loss. 

  

Working with date calculations was hard. The GNU date command works differently on some systems. I kept the date handling in one function. The one function lets me change the date handling quickly if I need to. 

  

6. Testing 

  

We tested the script fully by creating lists and running every operation the script supports. The tests added tasks, with fields and added tasks without fields. The tests viewed lists. Viewed populated lists. The tests searched for tasks. The tests completed tasks. The tests deleted tasks. 

Every single function is tested one by one, along with other functions together, to make sure that the script is acting as it should in a real situation. Bug fixes are made as they are generated, until all functions are behaving as they should. 

  

7. Possible Improvements 

  

If more time had been available, a number of additional improvements could have been included. These include an interactive menu-driven beginner mode, more sophisticated filtering and sorting functionality, archiving completed tasks rather than deleting them, and a calendar-based display of tasks. 

  

Another useful enhancement would be to validate inputs, for example, date validation, more strictly, as well as consider a more elegant way of handling optional inputs. 

  

8. Conclusion 

  

This activity has been very educational with regard to shell scripting as well as the design of command-line programs. It has been educational in terms of learning how to manipulate data with the use of files, how to interpret user inputs, as well as how to repair problems that come with scripting. The final todo.sh script submitted is complete with all the requirements set in the assignment exercise. 

 
